<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Proximity Voice Debug 2D</title>
<style>
body {margin:0;height:100vh;background:radial-gradient(circle at top,#0f172a,#020617);
font-family:system-ui,sans-serif;color:#e5e7eb;display:flex;align-items:center;justify-content:center;}
.card {background:rgba(15,23,42,0.85);border-radius:16px;padding:28px;width:360px;
box-shadow:0 20px 60px rgba(0,0,0,0.6);}
h1{margin:0 0 6px;font-size:22px;}
p{margin:0 0 16px;font-size:14px;color:#94a3b8;}
input{width:100%;padding:10px;border-radius:10px;border:none;margin-bottom:12px;}
button{width:100%;padding:10px;border-radius:10px;border:none;cursor:pointer;font-size:14px;background:#38bdf8;color:#020617;font-weight:600;}
button:hover{background:#0ea5e9;}
.hint{margin-top:14px;font-size:12px;color:#94a3b8;line-height:1.4;}
.status{margin-top:12px;font-size:13px;display:flex;align-items:center;gap:6px;}
.dot{width:10px;height:10px;border-radius:50%;background:#ef4444;}
.dot.active{background:#22c55e;}
.mute{margin-top:10px;background:#1e293b;color:#e5e7eb;}
.debug{margin-top:12px;font-size:11px;color:#94a3b8;max-height:150px;overflow-y:auto;background: rgba(0,0,0,0.2);padding:6px;border-radius:8px;}
</style>
</head>
<body>
<div class="card">
<h1>üéß Proximity Voice Debug 2D</h1>
<p>Private Runde ¬∑ Freunde only</p>
<input id="name" placeholder="Dein Name" />
<button onclick="joinVoice()">Voice beitreten</button>

<div class="status">
<div id="micDot" class="dot"></div>
<span id="micText">Mikrofon aus</span>
</div>
<button id="muteBtn" class="mute" onclick="toggleMute()" disabled>üîá Mute</button>

<div id="playerPositions" class="debug" style="max-height:200px;">
  <strong>üéÆ Spieler Positionen:</strong>
  <ul id="playersList" style="padding-left:16px;margin:4px 0;"></ul>
</div>

<div id="debug" class="debug"></div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
const audioCtx = new AudioContext();
let localStream = null;
const peers = {}; // id -> { pc, gain, name }
const pendingCandidates = {}; // id -> ICE array
const players = {}; // id -> {name, position}

const debugEl = document.getElementById("debug");
function logDebug(msg){
    console.log(msg);
    debugEl.innerText = msg+"\n"+debugEl.innerText;
}

// --------------------
// Join Voice
// --------------------
async function joinVoice(){
    const name = document.getElementById("name").value.trim();
    if(!name) return alert("Name fehlt üòÖ");

    localStream = await navigator.mediaDevices.getUserMedia({audio:true});
    await audioCtx.resume();
    logDebug("‚úÖ AudioContext resumed, mic active");

    socket.emit("join", name);

    document.getElementById("micDot").classList.add("active");
    document.getElementById("micText").innerText = "Mikrofon aktiv";
    document.getElementById("muteBtn").disabled = false;
}

// --------------------
// Mute toggle
// --------------------
let muted = false;
function toggleMute(){
    if(!localStream) return;
    muted = !muted;
    localStream.getAudioTracks()[0].enabled = !muted;
    document.getElementById("muteBtn").innerText = muted?"üé§ Unmute":"üîá Mute";
    document.getElementById("micText").innerText = muted?"Mikrofon stumm":"Mikrofon aktiv";
    logDebug("üîá Mute toggled: "+muted);
}

// --------------------
// Create Peer
// --------------------
function createPeer(id, initiator, name){
    if(!localStream){ logDebug("‚ö†Ô∏è localStream noch nicht bereit f√ºr " + id); return; }
    if(peers[id]) return;

    const pc = new RTCPeerConnection();
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    const gain = audioCtx.createGain();
    gain.gain.value = 1;
    gain.connect(audioCtx.destination);

    pc.ontrack = e => {
        const src = audioCtx.createMediaStreamSource(e.streams[0]);
        src.connect(gain);
        logDebug("üéß Track received from "+name+" ("+id+")");
    };

    pc.onicecandidate = e => {
        if(e.candidate) socket.emit("signal",{to:id, signal:{ice:e.candidate}});
    };

    peers[id] = { pc, gain, name };

    // WICHTIG: Initiator nur der ‚Äûfirst joiner‚Äú oder nach Regel
    if(initiator){
        pc.createOffer().then(o=>{
            pc.setLocalDescription(o);
            socket.emit("signal",{to:id, signal:{sdp:o}});
        });
    }
}


// --------------------
// Signaling
// --------------------
socket.on("signal", async data => {
    if(!peers[data.from]){
        const name = players[data.from]?.name || "unbekannt";
        createPeer(data.from,false,name); // immer Responder
    }
    const peer = peers[data.from];
    
    try {
        if(data.signal.sdp){
            const desc = new RTCSessionDescription(data.signal.sdp);

            if(desc.type === "offer"){
                // Responder: setzt RemoteDescription, erstellt Answer
                if(peer.pc.signalingState === "stable"){
                    await peer.pc.setRemoteDescription(desc);
                    const ans = await peer.pc.createAnswer();
                    await peer.pc.setLocalDescription(ans);
                    socket.emit("signal",{to:data.from, signal:{sdp:peer.pc.localDescription}});
                }
            } else if(desc.type === "answer"){
                // Initiator: setzt remoteDescription nur bei have-local-offer
                if(peer.pc.signalingState === "have-local-offer"){
                    await peer.pc.setRemoteDescription(desc);
                }
            }
        }

        if(data.signal.ice){
            const ice = new RTCIceCandidate(data.signal.ice);
            if(peer.pc.remoteDescription){
                await peer.pc.addIceCandidate(ice);
            } else {
                if(!peer.pendingCandidates) peer.pendingCandidates = [];
                peer.pendingCandidates.push(ice);
            }
        }

        // nach remoteDescription alle gepufferten ICE Candidates hinzuf√ºgen
        if(peer.pc.remoteDescription && peer.pendingCandidates){
            peer.pendingCandidates.forEach(c=>peer.pc.addIceCandidate(c));
            peer.pendingCandidates = [];
        }

    } catch(e){
        console.error("Fehler im Signal:", e);
    }
});


// --------------------
// Player Updates
// --------------------
socket.on("players", data=>{
    Object.assign(players, data);

    // Distance Audio
    const myPos = players[socket.id]?.position || {x:0,y:0,z:0};
    for(const id in peers){
        if(!players[id]) continue;
        const p = players[id].position;
        const dx = p.x - myPos.x;
        const dz = p.z - myPos.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        const vol = dist>70?0:dist<20?1:1-(dist-20)/50;
        peers[id].gain.gain.value = vol;
    }

    // Player Position List
    const ul = document.getElementById("playersList");
    ul.innerHTML = "";
    for(const id in players){
        const pos = players[id].position;
        const li = document.createElement("li");
        li.textContent = `${players[id].name} ‚Üí x:${pos.x.toFixed(1)} z:${pos.z.toFixed(1)}`;
        ul.appendChild(li);
    }
});

// --------------------
// User join/left
// --------------------
socket.on("user-joined", id => {
    if(!peers[id]){
        const name = players[id]?.name || "unbekannt";
        createPeer(id,true,name);
    }
});

socket.on("user-left", id => {
    if(peers[id]){
        peers[id].pc.close();
        delete peers[id];
        delete pendingCandidates[id];
        logDebug("‚ùå User left: "+id);
    }
});
</script>
</body>
</html>
